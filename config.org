This is my emacs config file.

* Package Management
#+BEGIN_SRC emacs-lisp
;; This must come before configurations of installed packages.  
(package-initialize)

;; Keep emacs-generated custom settings in a separate file so they don't pollute init.el
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file)

(require 'package)
#+END_SRC
Add repositories to search for required packages:
#+BEGIN_SRC emacs-lisp
;; setup package repos
(add-to-list 'package-archives 
             '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives
             '("melpa" . "http://melpa.milkbox.net/packages/") t)
(add-to-list 'package-archives
             '("melpa-stable" . "http://melpa-stable.org/packages/") t)
(add-to-list 'package-archives
             '("tromey" . "http://tromey.com/elpa/") t)
(add-to-list 'package-archives
             '("marmalade" . "http://marmalade-repo.org/packages/") t)
(add-to-list 'package-archives
             '("elpy" . "https://jorgenschaefer.github.io/packages/"))
(package-initialize)
#+END_SRC

Download the ELPA archive description if needed. This informs Emacs about the latest 
versions of all packages, and makes them available for download.
#+BEGIN_SRC emacs-lisp
(when (not package-archive-contents)
  (package-refresh-contents))
#+END_SRC
I run linux, but this may be useful for those who use OSX. Description:

   On OS X, an Emacs instance started from the graphical user
interface will have a different environment than a shell in a
terminal window, because OS X does not run a shell during the
login. Obviously this will lead to unexpected results when
calling external utilities like make from Emacs.
This library works around this problem by copying important
environment variables from the user's shell.
https://github.com/purcell/exec-path-from-shell
#+BEGIN_SRC emacs-lisp
(if (eq system-type 'darwin)
  (unless (package-installed-p 'exec-path-from-shell)
    (package-install 'exec-path-from-shell)))
#+END_SRC
Setup use-packages so that required packages will be installed when needed:
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-install 'use-package))

(setq use-package-verbose t)
(require 'use-package)
(use-package auto-compile
  :ensure t
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
(setq use-package-always-ensure t)
#+END_SRC
* General
** Basic Settings
Setup default window size:
#+BEGIN_SRC emacs-lisp 
(add-to-list 'default-frame-alist '(height . 40))
(add-to-list 'default-frame-alist '(width . 160))
#+end_src
Get rid of annoying stuff:
#+begin_src emacs-lisp
(setq gc-cons-threshold 100000000)
(setq inhibit-startup-message t)
#+end_src
Use 'y' instead of "yes" and 'n' instead of "no" at prompt.
#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src
Save point position between sessions:
#+begin_src emacs-lisp
(require 'saveplace)
(setq-default save-place t)
(setq save-place-file (expand-file-name ".places" user-emacs-directory))
#+end_src
No splash screen:
#+begin_src emacs-lisp
(setq inhibit-startup-screen t)
#+end_src
Set font:
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist
         '(font .  "Ubuntu Mono-12"))
(set-face-attribute 'default t :font  "Ubuntu Mono-12")
#+end_src
Get rid of UI clutter:
#+begin_src emacs-lisp
;; disables tool bar
(tool-bar-mode -1)
;; disables pmenu bar, can re-enable as a popub with 'C-mouse-3'
(menu-bar-mode -99)
;; no scroll bar please
(toggle-scroll-bar -1)
#+end_src
Dont truncate lines:
#+begin_src emacs-lisp
(toggle-truncate-lines)
(global-set-key (kbd "C-c ; t") 'toggle-truncate-lines)
#+end_src
I prefer a non-blinking cursor:
#+begin_src emacs-lisp
(blink-cursor-mode 0)
#+end_src
Faintly highlight current line:
#+begin_src emacs-lisp
(global-hl-line-mode 1)
(set-face-background 'hl-line "#3b3b3b")
(set-face-foreground 'highlight nil)
#+end_src
Set up mode line:
#+begin_src emacs-lisp
;; display time in mode linep
(display-time-mode t)
;; set modeline to powerline
(use-package powerline)
(powerline-default-theme)
#+END_SRC

** Key-Command Interfaces
Turn on ido. I prefer Ido's approach to find-file over helm's
approach:
#+begin_src emacs-lisp
(ido-mode t)

(bind-key* "C-x C-f" 'ido-find-file)
#+end_src

Custom key-binding scheme encapsulated in a minor mode called dwcB-mode so that it can be turned off and on easily:
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/dwcB/")

  (require 'dwc-bindings)
#+end_src

*** Key Chords
$key-chord-one-key-delay$ defines the max time delay between two key
presses to be considered a key chord.  I have this set to be very
short, short enough that to trigger the command, the keys pretty much
have to be pressed as one motion, and not in sequence. For example,
with this setting, I can't (realistically) trigger a command assigned
to "we" key chord by pressing 'w' and 'e' in sequence as I would
typing them in a word naturally. This makes two-handed keys chords
slightly unreliable, at least without practice. So generally, my key
chords consist of keys adjacent to one another.
#+BEGIN_SRC emacs-lisp
  (use-package key-chord
    :ensure t
    :init
    (setq key-chord-two-keys-delay 0.1)
    (setq key-chord-one-key-delay 0.1)
    (key-chord-mode 1)
  )
#+END_SRC
*** Hydra
#+begin_src emacs-lisp
  (use-package hydra
    :ensure t)
#+end_src
** Helm
This variables must be set before loading helm-gtags
#+BEGIN_SRC emacs-lisp
(setq helm-gtags-prefix-key "\C-cg")
#+END_SRC

*use-package Helm*
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :init
      (bind-keys
       :map dwcB-inter-buffer-map
       (dwcB-search-beta-key . helm-find-files)
       ((concat "C-" dwcB-search-beta-key) . helm-find-file-other-window)
       ((upcase dwcB-search-beta-key) . helm-find-file-other-frame))
      (bind-keys
       ("M-x" . helm-M-x)
       ("M-y" . helm-show-5ill-ring)
       ("C-h SPC" . helm-all-mark-rings)
       ("C-x b" . helm-mini)
       ;("C-x C-f" . helm-find-files)
       ("C-h SPC" . helm-all-mark-rings)
       ("C-c s o" . helm-occur))
    (setq
     helm-scroll-amount 4   ; scroll 4 lines other window using M-<next>/M-<prior>
     helm-ff-search-library-in-sexp t ; search for library in `require' and
                                          ; declare-function' sexp.
     helm-split-window-in-side-p t ; open helm buffer inside current window, not
                                          ; occupy whole other window
     helm-candidate-number-limit 500  ; limit the number of displayed canidates
     helm-ff-file-name-history-use-recentf t
     helm-move-to-line-cycle-in-source t ; move to end or beginning of source when
                                          ; reaching top or bottom of source.
     helm-buffers-fuzzy-matching t)   ; fuzzy matching buffer names when non-nil

    (helm-mode 1)
    :config
    (setq dwcB-helm-map (dwcB-add-major-map 'helm-mode nil helm-map (keymap-parent helm-map)))
    (bind-keys
     :map dwcB-helm-map
      ((concat "H-" dwcB-downward-key) . helm-next-line)
      ((concat "C-" dwcB-upward-key) . helm-previous-line)
     )
)
#+END_SRC
*** Basic Settings
Helm size
#+BEGIN_SRC emacs-lisp
(helm-autoresize-mode t)
(setq helm-autoresize-max-height 30)
(setq helm-autoresize-min-height 20)
#+end_src

#+begin_src emacs-lisp
(global-set-key (kbd "C-c h") 'helm-command-prefix-key)
(global-unset-key (kbd "C-x c"))

(define-key helm-map (kbd "C-\-") 'helm-execute-persistent-action) ; rebihnd tab to do persistent action
(define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)  ; make TAB works in terminal
(define-key helm-map (kbd "C-z")  'helm-select-action)             ; list actions using C-z

(define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
(define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
(define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)


(when (executable-find "curl")
  (setq helm-google-suggest-use-curl-p t))

(add-to-list 'helm-sources-using-default-as-input 'helm-source-man-pages)

(global-set-key (kbd "C-c 7 w") 'helm-wikipedia-suggest)
(global-set-key (kbd "C-c 7 g") 'helm-google-suggest)
(global-set-key (kbd "C-c 7 s") 'helm-surfraw)

;(global-set-key (kbd "C-c h M-:") 'helm-eval-expression-with-eldoc)
;(global-set-key (kbd "C-c h c") 'helm-calcul-expression)

;(global-set-key (kbd "C-c h x") 'helm-register)
;(global-set-key (kbd "C-x r j") 'jump-to-register)

(define-key 'help-command (kbd "C-f") 'helm-apropos)
(define-key 'help-command (kbd "r") 'helm-info-emacs)
(define-key 'help-command (kbd "C-l") 'helm-locate-library)

;;; Save current position to mark ring
(add-hook 'helm-goto-line-before-hook 'helm-save-current-pos-to-mark-ring)
#+END_SRC

Show minibuffer history with Helm
#+BEGIN_SRC emacs-lisp
(define-key minibuffer-local-map (kbd "M-p") 'helm-minibuffer-history)
#+END_SRC

Navigating file
#+BEGIN_SRC emacs-lisp
(define-key global-map [remap find-tag] 'helm-etags-select)

(define-key global-map [remap list-buffers] 'helm-buffers-list)
#+END_SRC

Use Helm to list eshell history:
#+BEGIN_SRC emacs-lisp
(add-hook 'eshell-mode-hook
          (lambda ()
              (local-set-key 'eshell-mode-map (kbd "C-c C-l") 'helm-eshell-history)))
#+END_SRC 

Fuzzy matching for elisp helm completion. E.g., (helm-M-x "fi ile") will have "find-file" as one of the possible completions.
#+BEGIN_SRC emacs-lisp
(setq helm-lisp-fuzzy-completion t)
#+END_SRC
* Interface
** Flycheck
*use-package Flycheck*
#+BEGIN_SRC emacs-lisp 
(use-package flycheck
  :init (progn
          (add-hook 'after-init-hook #'global-flycheck-mode))
  :bind (("C-c ! n" . flycheck-next-error)
         ("C-c ! p" . flycheck-previous-error)
         ("C-c ! h" . helm-flycheck)))
#+END_SRC

** Company
*use-package Company*
#+begin_src emacs-lisp
(use-package company
  :init
  (add-hook 'after-init-hook 'global-company-mode)
  :config (progn
            (setq company-backends (delete 'company-semantic company-backends))
            (use-package helm-company
              :bind ("C-c <tab>" . helm-company)))
  )
#+end_src

** Helm-swoop
*use-package helm-swoop*
#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :init (progn
          (global-set-key (kbd "C-c s s") 'helm-swoop)
          (global-set-key (kbd "C-c s a") 'helm-multi-swoop-all)
        )
  :config (progn
            ; When doing isearch, hand the word over to helm-swoop
            (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
            ; From helm-swoop to helm-multi-swoop-all
            (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)
            ; Save buffer when helm-multi-swoop-edit complete
            (setq helm-multi-swoop-edit-save t))
            ; If this value is t, split window inside the current window
            (setq helm-swoop-split-with-multiple-windows t)
            ;; Split direcion. 'split-window-vertically or 'split-window-horizontally
            (setq helm-swoop-split-direction 'split-window-vertically)
            ;; If nil, you can slightly boost invoke speed in exchange for text color
            (setq helm-swoop-speed-or-color t)
  )
#+END_SRC

** Other Packages
*** guide-key
Display possible key binding completions automatically in a small pop-up buffer with guide-key:
#+BEGIN_SRC emacs-lisp
(use-package guide-key
  :init
  (guide-key-mode 1)
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-x v" "C-x 8" "C-x +" "C-w" "C-e"))
  (setq guide-key/recursive-key-sequence-flag t)
  (setq guide-key/popup-window-position 'bottom)
)
#+END_SRC
*** rainbow-delimiters
Automatically color parentheses pairs different colors with rainbow-delimiters:
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :init
  (rainbow-delimiters-mode))
#+END_SRC

*** golden-ratio
Automatically resize buffers to "optimal" size when they gain focus. Turned off by default.
#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :commands golden-ratio golden-ratio-mode
    :init
    (bind-keys
     :map dwcB-inter-buffer-map
     ("b" . golden-ratio)
     ("B" . golden-ratio-mode))
    (bind-keys
     ("C-x w g SPC" . golden-ratio) ; Resize buffers according to golden-ratio
     ("C-x w g m" . golden-ratio-mode) ;; Enable/disable golden-ratio-mode
     )
    :config
    (progn
      ;; List of buffers to not be resized by golden-ratio.
      (setq golden-ratio-exclude-buffer-names
            '("*Flycheck errors*"
              "*SPEEDBAR*"))
      ;; Ensure golden-ratio compatibility with helm.
      (defun pl/helm-alive-p ()
        (if (boundp 'helm-alive-p)
            (symbol-value 'helm-alive-p)))
      (add-to-list 'golden-ratio-inhibit-functions 'pl/helm-alive-p))
    )
#+END_SRC

*** speedbar
#+BEGIN_SRC emacs-lisp
(use-package sr-speedbar)

;(setq speedbar-show-unknown-files t)
#+END_SRC

*** zygospore
#+BEGIN_SRC emacs-lisp 
(use-package zygospore
  :bind ("C-x 1" . zygospore-toggle-delete-other-windows))
#+END_SRC

* Navigation
** Basic Settings
Quickly move the cursor to the first instance of a character with iy-go-to-char:
#+begin_src emacs-lisp
(use-package iy-go-to-char
  :init (progn
          (key-chord-define-global "fg" 'iy-go-to-char)
          (key-chord-define-global "df" 'iy-go-to-char-backward))
  )
#+end_src
General navigation bindings:
#+begin_src emacs-lisp
(key-chord-define-global "fp" 'find-file-at-point)

(global-unset-key (kbd "C-x 5 0"))
(global-set-key (kbd "C-x 5 DEL") 'delete-frame)

(global-unset-key (kbd "C-x 0"))
(global-set-key (kbd "C-x DEL") 'delete-window)
#+end_src
** windmove
Navigate windows directionally with wind-move:
#+BEGIN_SRC emacs-lisp
  (use-package windmove
    :commands
    ;; Here because alternative commands (key chords) do not trigger package autoload.
    (windmove-left windmove-right windmove-up windmove-down)
    :init
    (bind-keys
     :map dwcB-inter-buffer-map
     ((concat "C-" dwcB-forward-key) . windmove-right)
     ((concat "C-" dwcB-backward-key) . windmove-left)
     ((concat "C-" dwcB-upward-key) . windmove-up)
     ((concat "C-" dwcB-downward-key) . windmove-down))
    (bind-keys
     ("C-x w j" . windmove-left)
     ("C-x w l" . windmove-right)
     ("C-x w i" . windmove-up)
     ("C-x w k" . windmove-down))
    (key-chord-define-global "wj" 'windmove-left)
    (key-chord-define-global "wl" 'windmove-right)
    (key-chord-define-global "wi" 'windmove-up)
    (key-chord-define-global "wk" 'windmove-down))
#+END_SRC
** ace-jump-mode
Jump quickly to any word using just two key strokes with ace-jump-mode:
#+BEGIN_SRC emacs-lisp
(use-package ace-jump-mode
  :commands ace-jump-mode
  :init
  (key-chord-define-global "cj" 'ace-jump-mode))
#+END_SRC
** ace-window
Jump quickly between windows and frames using just two key strokes with ace-window:
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :commands ace-window
  :init
  (key-chord-define-global "xo" 'ace-window))
#+END_SRC
** Functions
Switch between the two most recently visited buffers:
#+BEGIN_SRC emacs-lisp
(defun switch-to-other-buffer ()
  "Switch to last visited buffer."
  (interactive)
  (switch-to-buffer (other-buffer) (current-buffer) 1))
(global-set-key (kbd "C-c b") 'switch-to-other-buffer)
#+END_SRC
Maximize the current buffer:
#+BEGIN_SRC emacs-lisp
(defun toggle-maximize-buffer ()
  "Maximize/minimize buffer"
       (interactive)
       (if (= 1 (length (window-list)))
           (jump-to-register '_)
         (progn
           (window-configuration-to-register '_)
           (delete-other-windows))))
(key-chord-define-global "xm" 'toggle-maximize-buffer)
#+END_SRC
Transpose two windows:
#+BEGIN_SRC emacs-lisp
(defun transpose-windows (arg)
  "Transpose the buffers shown in two windows."
  (interactive "p")
  (let ((selector (if (>= arg 0) 'next-window 'previous-window)))
    (while (/= arg 0)
      (let ((this-win (window-buffer))
            (next-win (window-buffer (funcall selector))))
        (set-window-buffer (selected-window) next-win)
        (set-window-buffer (funcall selector) this-win)
        (select-window (funcall selector)))
      (setq arg (if (plusp arg) (1- arg) (1+ arg))))))
(global-set-key (kbd "C-x w t") 'transpose-windows)
#+END_SRC
* Editing
** Basic Settings
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)

;; Highlight current line
(global-hl-line-mode 1)

(setq global-mark-ring-max 5000         ; increase mark ring to contains 5000 entries
      mark-ring-max 10000                ; increase kill ring to contains 10000 entries
      mode-require-final-newline t      ; add a newline to end of file
      tab-width 4)                       ; default to 4 visible spaces to display a tab

(add-hook 'sh-mode-hook (lambda ()
                          (setq tab-width 4)))

(setq kill-ring-max 10000 ; increase kill-ring capacity
      kill-whole-line t)  ; if NIL, kill whole line and move the next line up

;; key-chord for add region to kill ring
(key-chord-define-global "qw" 'kill-ring-save)

;; show whitespace in diff-mode
(add-hook 'diff-mode-hook (lambda ()
                            (setq-local whitespace-style
                                        '(face
                                          tabs
                                          tab-mark
                                          spaces
                                          space-mark
                                          trailing
                                          indentation::space
                                          indentation::tab
                                          newline
                                          newline-mark))
                            (whitespace-mode 1)))

(setq electric-indent-mode nil)

(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)

;; show unncessary whitespace that can mess up your diff
(add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))

;; use space to indent by default
(setq-default indent-tabs-mode nil)

;; set appearance of a tab that is represented by 4 spaces
(setq-default tab-width 4)
#+END_SRC
*** Key commands
#+BEGIN_SRC emacs-lisp 
;; delete region command is useful sometimes where <delete> doesnt work
(global-set-key (kbd "C-c <delete>") 'delete-region)

;; remap backward-char to something more comfortable
;(setq map (make-sparse-keymap))
;(define-key map "\C-v" 'backward-char)

;; folding
(add-hook 'c-mode-common-hook 'hs-minor-mode)
(global-set-key (kbd "C-c f t") 'hs-toggle-hiding)
(global-set-key (kbd "C-c f h") 'hs-hide-block)
(global-set-key (kbd "C-c f s") 'hs-show-block)
(global-set-key (kbd "C-c f a h") 'hs-hide-all)
(global-set-key (kbd "C-c f a s") 'hs-show-all)
;; narrowing
(global-set-key (kbd "C-x n d") 'narrow-to-defun)
(global-set-key (kbd "C-x n r") 'narrow-to-region)
(global-set-key (kbd "C-x n w") 'widen)
(key-chord-define-global "m," 'narrow-to-region)
(key-chord-define-global ",." 'widen)

; automatically indent when press RET
(global-set-key (kbd "RET") 'newline-and-indent)

;; activate whitespace-mode to view all whitespace characters
(global-set-key (kbd "C-c w") 'whitespace-mode)

(key-chord-define-global "rk" 'delete-whitespace-rectangle)

(key-chord-define-global ";/" 'comment-region)
(key-chord-define-global "/." 'uncomment-region)
#+END_SRC

#+END_SRC
** UTF-8
#+BEGIN_SRC emacs-lisp 
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)

(setq-default indent-tabs-mode nil)
(delete-selection-mode)
(global-set-key (kbd "RET") 'newline-and-indent)

(define-key key-translation-map (kbd "C-c u p") (kbd "φ"))
(define-key key-translation-map (kbd "C-c u x") (kbd "ξ"))
(define-key key-translation-map (kbd "C-c u i") (kbd "∞"))
(define-key key-translation-map (kbd "C-c u l") (kbd "λ"))
(define-key key-translation-map (kbd "C-c u <right>") (kbd "→"))

(define-abbrev-table 'global-abbrev-table '(
                                            ("alpha" "α")
                                            ("inf" "∞")
                                            ("ar" "→")
                                            ("lambda" "λ")
                                            ))
(abbrev-mode 1)
#+END_SRC
*** char-menu
#+BEGIN_SRC emacs-lisp 
(use-package char-menu)

(require 'char-menu)
(key-chord-define-global "cm" 'char-menu)
(setq char-menu '("—" "‘’" "“”" "…" "«»" "–"
                        ("Typography" "•" "©" "†" "‡" "°" "·" "§" "№" "★")
                        ("Math"       "≈" "≡" "≠" "∞" "×" "±" "∓" "÷" "√")
                        ("Arrows"     "←" "→" "↑" "↓" "⇐" "⇒" "⇑" "⇓")
                        ("Greek"      "α" "β" "Y" "δ" "ε" "ζ" "η" "θ" "ι" "κ" "λ" "μ"
                         "ν" "ξ" "ο" "π" "ρ" "σ" "τ" "υ" "φ" "χ" "ψ" "ω")))


#+END_SRC

** Smartparens
*use-package smartparents*
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :config
  (sp-pair "'" nil :unless '(sp-point-after-word-p) :actions nil)

  (setq sp-base-key-bindings 'paredit)
  (setq sp-autoskip-closing-pair 'always)
  (setq sp-hybrid-kill-entire-symbol nil)
  (setq sp-backward-delete-char 'paredit-backward-delete)
  (sp-use-paredit-bindings)

  (show-smartparens-global-mode +1)
  (smartparens-global-mode 1)

  (add-hook 'prog-mode-hook 'turn-on-smartparens-mode)
  (add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode)
)
#+END_SRC
*** TODO sp-delete-sexp
    SCHEDULED: <2016-02-07 Sun>        
    - Note taken on [2016-02-06 Sat 16:09] \\
      Currently broken.
#+BEGIN_SRC emacs-lisp
(defun sp-delete-sexp ()
"Deletes sexp at point. Does not save to kill ring."
    (interactive)
    (sp-forward-sexp)
    (sp-backward-sexp)
    (mark)
    (sp-forward-sexp)
  (delete-region (point) (mark)))
#+END_SRC

*** bind-keys
#+BEGIN_SRC emacs-lisp 
(bind-keys
 :map smartparens-mode-map
 ("C-' a" . sp-beginning-of-sexp)
 ("C-' e" . sp-end-of-sexp)

 ("C-' k" . sp-down-sexp)
 ("C-' i"   . sp-up-sexp)
 ("C-' j" . sp-backward-down-sexp)
 ("C-' l"   . sp-backward-up-sexp)

 ("C-' f" . sp-forward-sexp)
 ("C-' b" . sp-backward-sexp)

 ("C-' n" . sp-next-sexp)
 ("C-' p" . sp-previous-sexp)

 ("C-' h" . sp-forward-symbol)
 ("C-' g" . sp-backward-symbol)

 ("C-' t" . sp-forward-slurp-sexp)
 ("C-' w" . sp-forward-barf-sexp)
 ("C-' r"  . sp-backward-slurp-sexp)
 ("C-' q"  . sp-backward-barf-sexp)

 ("C-' C-t" . sp-transpose-sexp)
 ("C-' k" . sp-kill-sexp)
 ("C-' h"   . sp-kill-hybrid-sexp)
 ("C-' C-k"   . sp-backward-kill-sexp)
 ("C-' C-w" . sp-copy-sexp)

 ("C-' d" . sp-delete-sexp)        ;; this function doesnt exist?

 ("<backspace>" . sp-backward-delete-char)
 ("C-<backspace>" . backward-delete-char)     ;; this should be like paredit
 ("M-<backspace>" . sp-backward-kill-word)     ;; this should be like paredit
 ("M-s-<backspace>" . backward-kill-word)     ;; this should be like paredit
 ([remap sp-backward-kill-word] . backward-kill-word)

 ("M-[" . sp-backward-unwrap-sexp)
 ("M-]" . sp-unwrap-sexp)
 ("M-s-[" . sp-rewrap-sexp)

 ("C-x C-t" . sp-transpose-hybrid-sexp)

 ("C-c ("  . wrap-with-parens)
 ("C-c ["  . wrap-with-brackets)
 ("C-c {"  . wrap-with-braces)
 ("C-c '"  . wrap-with-single-quotes)
 ("C-c \"" . wrap-with-double-quotes)
 ("C-c _"  . wrap-with-underscores)
 ("C-c `"  . wrap-with-back-quotes))
#+END_SRC
*** key-chord
#+BEGIN_SRC emacs-lisp
;; Key bindings
(key-chord-define-global "8a" 'sp-beginning-of-sexp)
(key-chord-define-global "8e" 'sp-end-of-sexp)

(key-chord-define-global "4k" 'sp-down-sexp)
(key-chord-define-global "4i"   'sp-up-sexp)
(key-chord-define-global "4j" 'sp-backward-down-sexp)
(key-chord-define-global "4l"   'sp-backward-up-sexp)

(key-chord-define-global "8f" 'sp-forward-sexp)
(key-chord-define-global "8b" 'sp-backward-sexp)

(key-chord-define-global "4n" 'sp-next-sexp)
(key-chord-define-global "4p" 'sp-previous-sexp)

(key-chord-define-global "4h" 'sp-forward-symbol)
(key-chord-define-global "8g" 'sp-backward-symbol)

(key-chord-define-global "8t" 'sp-forward-slurp-sexp)
(key-chord-define-global "8w" 'sp-forward-barf-sexp)
(key-chord-define-global "8r"  'sp-backward-slurp-sexp)
(key-chord-define-global "8q"  'sp-backward-barf-sexp)

(key-chord-define-global "4t" 'sp-transpose-sexp)
(key-chord-define-global "4k" 'sp-kill-sexp)
(key-chord-define-global "4h" 'sp-kill-hybrid-sexp)
(key-chord-define-global "4j" 'sp-backward-kill-sexp)
(key-chord-define-global "4w" 'sp-copy-sexp)

(key-chord-define-global "8d" 'sp-delete-sexp)        ;; this function doesnt exist?

;("<backspace>" . sp-backward-delete-char)
;("C-<backspace>" . backward-delete-char)     ;; this should be like paredit
;("M-<backspace>" . sp-backward-kill-word)     ;; this should be like paredit
;("M-s-<backspace>" . backward-kill-word)     ;; this should be like paredit
;([remap sp-backward-kill-word] . backward-kill-word)

(key-chord-define-global "u9" 'sp-backward-unwrap-sexp)
(key-chord-define-global "u0" 'sp-unwrap-sexp)
(key-chord-define-global "90" 'sp-rewrap-sexp) ; this is probably a poor choice, but whatever.

(key-chord-define-global "r9"  'wrap-with-parens)
(key-chord-define-global "r["  'wrap-with-brackets)
(key-chord-define-global "r{"  'wrap-with-braces)
(key-chord-define-global "r'"  'wrap-with-single-quotes)
(key-chord-define-global "r\"" 'wrap-with-double-quotes)
(key-chord-define-global "r_"  'wrap-with-underscores)
(key-chord-define-global "r`"  'wrap-with-back-quotes)
#+END_SRC 

** Other Packages
*** hippie-expand
#+BEGIN_SRC emacs-lisp 
;; Hippie expand-file-name
(global-set-key (kbd "M-/") 'hippie-expand)
;; Lisp-friendly hippie expand
(setq hippie-expand-try-functions-list
      '(try-expand-dabbrev
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol))
#+END_SRC

*** volatile-highlights
#+BEGIN_SRC emacs-lisp
(use-package volatile-highlights
  :config
  (volatile-highlights-mode t))
#+END_SRC
*** clean-auto-indent-mode
#+BEGIN_SRC emacs-lisp
(use-package clean-aindent-mode
  :commands clean-aindent-mode
  :init
  (add-hook 'prog-mode-hook 'clean-aindent-mode))
#+END_SRC
*** dtrt-indent
#+BEGIN_SRC emacs-lisp 
(use-package dtrt-indent  
  :config
  (setq dtrt-indent-verbosity 0)
  (dtrt-indent-mode 1))
#+END_SRC
*** ws-butler
#+BEGIN_SRC emacs-lisp 
(use-package ws-butler
  :commands ws-butler
  :init
  (add-hook 'c-mode-common-hook 'ws-butler-mode)
  (add-hook 'text-mode 'ws-butler-mode)
  (add-hook 'fundamental-mode 'ws-butler-mode)
  (add-hook 'prog-mode-hook 'ws-butler-mode))
#+END_SRC
*** undo-tree
#+BEGIN_SRC emacs-lisp 
(use-package undo-tree
  :config
  (global-undo-tree-mode))
#+END_SRC
*** yasnippet
#+BEGIN_SRC emacs-lisp 
(use-package yasnippet
  :commands
  (yas/exit-all-snippets
   yas/goto-end-of-active-field    ;; Defined below
   yas/goto-start-of-active-field  ;; Defined below
   yas-expand)
  :init
  (yas-global-mode 1)
  ;; Bindings
  (bind-key "<return>" 'yas/exit-all-snippets yas-keymap)
  (bind-key "C-e" 'yas/goto-end-of-active-field yas-keymap)
  (bind-key "C-a" 'yas/goto-start-of-active-field yas-keymap)
  (bind-key [(tab)] 'nil yas-minor-mode-map)
  (bind-key (kbd "TAB") 'nil yas-minor-mode-map)
  (bind-key (kbd "C-<tab>") 'yas-expand yas-minor-mode-map)
  :functions (yas/goto-end-of-active-field yas/goto-start-of-active-field)
  :config
  (progn
    (setq yas-verbosity 1) ;; No need to be so verbose
    (setq yas-wrap-around-region t) ;; Wrap around region
    (setq yas-prompt-functions '(yas/ido-prompt yas/completing-prompt))
    (defun my/yas-term-hook ()
      (setq yas-dont-activate t))
    (add-hook 'term-mode-hook 'my/yas-term-hook))
  )
#+end_src

Inter-field navigation:
#+being_src emacs-lisp
;; Go to end of active field
(defun yas/goto-end-of-active-field ()
  (interactive)
  (let* ((snippet (car (yas--snippets-at-point)))
         (position (yas--field-end (yas--snippet-active-field snippet))))
    (if (= (point) position)
        (move-end-of-line 1)
      (goto-char position))))

;; Go to start of active field
(defun yas/goto-start-of-active-field ()
  (interactive)
  (let* ((snippet (car (yas--snippets-at-point)))
         (position (yas--field-start (yas--snippet-active-field snippet))))
    (if (= (point) position)
        (move-beginning-of-line 1)
      (goto-char position))))
#+end_src
*** anzu
#+BEGIN_SRC emacs-lisp 
(use-package anzu
  :commands
  (anzu-query-replace
   anzu-query-replace-regexp)
  :init
  ;; Bindings
  (bind-key "M-%" 'anzu-query-replace)
  (bind-key "C-M-%" 'anzu-query-replace-regexp)
  :config
  (global-anzu-mode)
  )
#+END_SRC
*** iedit
#+BEGIN_SRC emacs-lisp 
(use-package iedit
  :commands iedit-mode
  :init
  (bind-key "C-;" 'iedit-mode)
  :config
  (setq iedit-toggle-key-default nil)
  )
#+END_SRC
*** expand-region
#+BEGIN_SRC emacs-lisp 
(use-package expand-region
  :commands er/expand-region
  :init
  (key-chord-define-global ";l" 'er/expand-region)
 )
#+END_SRC
*** duplicate-thing
#+BEGIN_SRC emacs-lisp 
(use-package duplicate-thing
  :commands duplicate-thing
  :init
  (bind-key "M-c" 'duplicate-thing)
 )
#+END_SRC 

** Functions
*** die-tabs
#+BEGIN_SRC emacs-lisp
(defun die-tabs ()
"use 2 spaces for tabs"
  (interactive)
  (set-variable 'tab-width 2)
  (mark-whole-buffer)
  (untabify (region-beginning) (region-end))
  (keyboard-quit))
#+END_SRC
*** prelude-move-beginning-of-line
#+BEGIN_SRC emacs-lisp
;; Customized functions
(defun prelude-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first. If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key (kbd "C-a") 'prelude-move-beginning-of-line)
#+END_SRC

*** defadvice kill-ring-save
#+BEGIN_SRC emacs-lisp 
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single
line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (message "Copied line")
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+END_SRC

*** defadvice kill-region
#+BEGIN_SRC emacs-lisp 
(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single
  line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
     (list (line-beginning-position)
           (line-beginning-position 2)))))
#+END_SRC

*** defadvice kill-line
#+BEGIN_SRC emacs-lisp 
;; kill a line, including whitespace characters until next non-whiepsace character
;; of next line
(defadvice kill-line (before check-position activate)
  (if (member major-mode
              '(emacs-lisp-mode scheme-mode lisp-mode
                                c-mode c++-mode objc-mode
                                latex-mode plain-tex-mode))
      (if (and (eolp) (not (bolp)))
          (progn (forward-char 1)
                 (just-one-space 0)
                 (backward-char 1)))))
#+END_SRC
*** variables
yank-indent-modes
#+BEGIN_SRC emacs-lisp 
;; taken from prelude-editor.el
;; automatically indenting yanked text if in programming-modes
(defvar yank-indent-modes
  '(LaTeX-mode TeX-mode)
  "Modes in which to indent regions that are yanked (or yank-popped).
Only modes that don't derive from `prog-mode' should be listed here.")
#+END_SRC

yank-indent-blacklisted-modes
#+BEGIN_SRC emacs-lisp 
(defvar yank-indent-blacklisted-modes
  '(python-mode slim-mode haml-mode)
  "Modes for which auto-indenting is suppressed.")
#+END_SRC

yank-advised-indent-threshol
#+BEGIN_SRC emacs-lisp 
(defvar yank-advised-indent-threshold 1000
  "Threshold (# chars) over which indentation does not automatically occur.")
#+END_SRC

yank-advised-indent-function
#+BEGIN_SRC emacs-lisp 
(defun yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) yank-advised-indent-threshold)
      (indent-region beg end nil)))
#+END_SRC

*** defadvice yank
#+BEGIN_SRC emacs-lisp 
(defadvice yank (after yank-indent activate)
  "If current mode is one of 'yank-indent-modes,
indent yanked text (with prefix arg don't indent)."
  (if (and (not (ad-get-arg 0))
           (not (member major-mode yank-indent-blacklisted-modes))
           (or (derived-mode-p 'prog-mode)
               (member major-mode yank-indent-modes)))
      (let ((transient-mark-mode nil))
        (yank-advised-indent-function (region-beginning) (region-end)))))
#+END_SRC

*** defadvice yank-pop
#+BEGIN_SRC emacs-lisp 
(defadvice yank-pop (after yank-pop-indent activate)
  "If current mode is one of `yank-indent-modes',
indent yanked text (with prefix arg don't indent)."
  (when (and (not (ad-get-arg 0))
             (not (member major-mode yank-indent-blacklisted-modes))
             (or (derived-mode-p 'prog-mode)
                 (member major-mode yank-indent-modes)))
    (let ((transient-mark-mode nil))
      (yank-advised-indent-function (region-beginning) (region-end)))))
#+END_SRC

*** indent-buffer
#+BEGIN_SRC emacs-lisp
;; prelude-core.el
(defun indent-buffer ()
  "Indent the currently visited buffer."
  (interactive)
  (indent-region (point-min) (point-max)))
#+END_SRC

*** prelude-indent-sensitive-modes
#+BEGIN_SRC emacs-lisp 
;; prelude-editing.el
(defcustom prelude-indent-sensitive-modes
  '(coffee-mode python-mode slim-mode haml-mode yaml-mode)
  "Modes for which auto-indenting is suppressed."
  :type 'list)
#+END_SRC

*** indent-region-or-buffer
#+BEGIN_SRC emacs-lisp 
(defun indent-region-or-buffer ()
  "Indent a region if selected, otherwise the whole buffer."
  (interactive)
  (unless (member major-mode prelude-indent-sensitive-modes)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (indent-buffer)
          (message "Indented buffer.")))
      (whitespace-cleanup))))

(global-set-key (kbd "C-c i") 'indent-region-or-buffer)
#+END_SRC

*** prelude-get-positions-of-line-or-region
#+BEGIN_SRC emacs-lisp 
;; add duplicate line function from Prelude. taken from prelude-core.el.
(defun prelude-get-positions-of-line-or-region ()
  "Return positions (beg . end) of the current line
or region."
  (let (beg end)
    (if (and mark-active (> (point) (mark)))
        (exchange-point-and-mark))
    (setq beg (line-beginning-position))
    (if mark-active
        (exchange-point-and-mark))
    (setq end (line-end-position))
    (cons beg end)))
#+END_SRC

*** prelude-smart-open-line

smart openline

#+BEGIN_SRC emacs-lisp 
(defun prelude-smart-open-line (arg)
  "Insert an empty line after the current line.
Position the cursor at its beginning, according to the current mode.
With a prefix ARG open line above the current line."
  (interactive "P")
  (if arg
      (prelude-smart-open-line-above)
    (progn
      (move-end-of-line nil)
      (newline-and-indent))))
#+END_SRC

*** prelude-smart-open-line-above
#+BEGIN_SRC emacs-lisp 
(defun prelude-smart-open-line-above ()
  "Insert an empty line above the current line.
Position the cursor at it's beginning, according to the current mode."
  (interactive)
  (move-beginning-of-line nil)
  (newline-and-indent)
  (forward-line -1)
  (indent-according-to-mode))

(global-set-key (kbd "M-o") 'prelude-smart-open-line)
(global-set-key (kbd "M-o") 'open-line)


(add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (set (make-local-variable 'company-backends) '(company-elisp))))
#+END_SRC

*** toggle-comment-on-line
Comment out a line:
#+BEGIN_SRC emacs-lisp
(defun toggle-comment-on-line ()
  "comment or uncomment current line"
  (interactive)
  (comment-or-uncomment-region (line-beginning-position) (line-end-position)))
(key-chord-define-global ";'" 'toggle-comment-on-line)
#+END_SRC

* Development Environments
** General Settings
*** Semantic
#+begin_src emacs-lisp
(semantic-mode 1)

(global-semanticdb-minor-mode 1)

(global-semantic-idle-scheduler-mode 1)

(global-semantic-stickyfunc-mode 1)
#+end_src
*** Compilation
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f5>") (lambda ()
                               (interactive)
                               (setq-local compilation-read-command nil)
                               (call-interactively 'compile)))
#+END_SRC

*** Debugging
#+BEGIN_SRC emacs-lisp
;; Setup GDB
(setq gdb-many-windows t
 ;; Non-nil means display source file containing the main routine at startup
 gdb-show-main t)
#+END_SRC

*** Projectile
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (projectile-global-mode)
  (setq projectile-enable-caching t))

(use-package helm-projectile
  :config
  (helm-projectile-on)
  (setq projectile-completion-system 'helm)
  (setq projectile-indexing-method 'alien))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq tramp-default-method "ssh")
#+END_SRC
 
*** Gtags
#+BEGIN_SRC emacs-lisp
(use-package helm-gtags
  :commands helm-gtags-mode
  :bind
  (("C-c g a" . helm-gtags-tags-in-this-function)
   ("C-j" . helm-gtags-select)
   ("M-." . helm-gtags-dwim)
   ("M-," . helm-gtags-pop-stack)
   ("C-c <" . helm-gtags-previous-history)
   ("C-c >" . helm-gtags-next-history))
  :init
  ; Enable helm-gtags-mode in Eshell for the same reason as above:
  (add-hook 'dired-mode-hook 'helm-gtags-mode)
  ; Enable helm-gtags-mode in languages that GNU Global supports:
  (add-hook 'eshell-mode-hook 'helm-gtags-mode)
  ; Enable helm-gtags-mode in Dired so you can jump to any tag when navigating project
  (add-hook 'c-mode-hook 'helm-gtags-mode)
  (add-hook 'c++-mode-hook 'helm-gtags-mode)
  (add-hook 'java-mode-hook 'helm-gtags-mode)
  :config
  (setq
   helm-gtags-ignore-case t
   helm-gtags-auto-update t
   helm-gtags-use-input-at-cursor t
   helm-gtags-pulse-at-cursor t
   helm-gtags-prefix-key "\C-cg"
   helm-gtags-suggested-key-mapping t)
  )
#+END_SRC
** Lisps
*** General Lisp Settings
Define hooks:
General Lisp hook:
#+begin_src emacs-lisp
  (defun my/general-lisp-hook ()
    (rainbow-delimiters-mode-enable)
    )
#+end_src
Emacs Lisp hook:
#+begin_src emacs-lisp
  (defun my/emacs-lisp-hook ()
        (my/general-lisp-hook)
        (turn-on-eldoc-mode)
        )
#+end_src
Add hooks:
#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'my/emacs-lisp-hook)
(add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
#+end_src
Enable rainbow-delimiters for lisp modes
#+BEGIN_SRC emacs-lisp
;(autoload 'enable-paredit-mode "paredit" "Turn on pseudo-structural editing of Lisp code." t)
(add-hook 'eval-expression-minibuffer-setup-hook 'my/general-lisp-hook)
(add-hook 'ielm-mode-hook             'my/general-lisp-hook)
(add-hook 'lisp-mode-hook            'my/general-lisp-hook)
(add-hook 'scheme-mode-hook           'my/general-lisp-hook)
;; pretty sure this isnt necessary
;(add-hook 'lisp-interaction-mode-hook (lambda () (my/general-lisp-hook))) 

#+end_src
Enable eldoc-mode in appropriate emacs lisp hooks
#+begin_src emacs-lisp
;; eldoc-mode shows documentation in the minibuffer when writing code
;; http://www.emacswiki.org/emacs/ElDoc
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
#+END_SRC
*** Emacs Lisp
#+begin_src emacs-lisp
(define-prefix-command 'Apropos-Prefix nil "Apropos (a,c,d,i,l,v,C-v)")
(global-set-key (kbd "C-h C-a") 'Apropos-Prefix)
(define-key Apropos-Prefix (kbd "a")   'apropos)
(define-key Apropos-Prefix (kbd "C-a") 'apropos)
(define-key Apropos-Prefix (kbd "c")   'apropos-command)
(define-key Apropos-Prefix (kbd "d")   'apropos-documentation)
(define-key Apropos-Prefix (kbd "i")   'info-apropos)
(define-key Apropos-Prefix (kbd "l")   'apropos-library)
(define-key Apropos-Prefix (kbd "v")   'apropos-variable)
(define-key Apropos-Prefix (kbd "C-v") 'apropos-value)
#+end_src

#+begin_src emacs-lisp
(eldoc-mode 1)
#+end_src

#+begin_src emacs-lisp
(defun my/bindkey-ielm-other-window ()
  (local-set-key (kbd "<f9>") (lambda ()
                                (let ((ielm-buffer (get-buffer "*ielm*")))
                                  (if (equal ielm-buffer nil)
                                      (ielm)
                                    (switch-to-buffer-other-window ielm-buffer)))
                                )))

(add-hook 'emacs-lisp-mode-hook 'my/bindkey-ielm-other-window)
#+end_src

Display possible symbol completions in a helm buffer:
#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "C-c l c") 'helm-lisp-completion-at-point)
#+END_SRC
*** Clojure
**** clojure-mode
My clojure-mode hook
#+begin_src emacs-lisp
  (defun my/clojure-mode-hook ()
    (my/general-lisp-hook)
    (subword-mode)
    (setq inferior-lisp-program "lein repl")
    (font-lock-add-keywords
     nil
     '(("(\\(facts?\\)"
        (1 font-lock-keyword-face))
       ("(\\(background?\\)"
        (1 font-lock-keyword-face))
       ))
    (define-clojure-indent (fact 1))
    (define-clojure-indent (facts 1))
    )
#+end_src

#+BEGIN_SRC emacs-lisp
  (use-package clojure-mode
    :mode "\\.clj\\'"
    :init
    ;; Use clojure-mode for other file-name extensions
    (add-to-list 'auto-mode-alist '("\\.edn$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.boot$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("\\.cljs.*$" . clojure-mode))
    (add-to-list 'auto-mode-alist '("lein-env" . enh-ruby-mode))
    ;; Define the clojure-mode-map prefix
    :config
      (use-package clojure-mode-extra-font-locking)
      (use-package flycheck-clojure)
      ;; A little more syntax highlighting
      (require 'clojure-mode-extra-font-locking)
                                          ;(use-package clj-refactor)
      (add-hook 'clojure-mode-hook 'my/clojure-mode-hook)
    )
#+END_SRC
**** CIDER
#+BEGIN_SRC emacs-lisp 
  (use-package cider
    :commands cider-mode
    :functions (cider-start-http-server cider-refresh cider-user-ns)
    :config
    (require 'clojure-mode-extra-font-locking)
;    (if use-dwc-key-bindings
 ;       (progn
  ;        (define-prefix-command 'cider-mode-map)
;          (global-set-key (kbd dwc-major-prefix) 'cider-mode-map)
;          (set-keymap-parent cider-mode-map lisp-mode-shared-map)
;          (bind-keys
 ;          :map cider-mode-map
;           ("C-c u" . cider-user-ns)
;           ("C-`" . cider-jack-in))
;          (bind-keys
;           :map clojure-mode-map
;           ("z" . cider-start-http-server)
;           ("x" . cider-refresh)
;           ("c" . cider-user-ns))
;         )
      (progn
        (bind-keys
         ("C-' 1" . cider-visit-error-buffer))
        (bind-keys
         :map clojure-mode-map
         ("C" . cider-start-http-server)
         ( "C-c r" . cider-refresh)
         ("C-c u" . cider-user-ns))
        (bind-keys
         :map cider-mode-map
         ("C-c u" . cider-user-ns)
         ("C-`" . cider-jack-in))
      ;)
      ;; Provides minibuffer documentation for the code you're typing into the repl
      (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
      (setq cider-repl-pop-to-buffer-on-connect t) ;; Go right to the REPL buffer when
      ;; it's finished connecting
      (setq cider-show-error-buffer nil) ;; When there's a cider error, show its buffer
      ;; and switch to it
      (setq cider-auto-select-error-buffer t)
      (setq cider-repl-history-file "~/.emacs.d/cider-history") ;; Where to store the
      ;; cider history.
      (setq cider-repl-wrap-history t) ;; Wrap when navigating history.
      ;; CIDER and clojure-mode specific bindings:
      ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun cider-start-http-server ()
  (interactive)
  (cider-load-current-buffer)
  (let ((ns (cider-current-ns)))
    (cider-repl-set-ns ns)
    (cider-interactive-eval (format "(println '(def server (%s/start))) (println 'server)" ns))
    (cider-interactive-eval (format "(def server (%s/start)) (println server)" ns))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun cider-refresh ()
  (interactive)
  (cider-interactive-eval (format "(user/reset)")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun cider-user-ns ()
  (interactive)
  (cider-repl-set-ns "user"))
#+END_SRC

** Python
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :commands (elpy-mode elpy-enable)
  :init
  (defun elpy-on-python-mode ()
    (elpy-mode)
    (elpy-enable))
  (add-hook 'python-mode-hook
            'elpy-on-python-mode)
  )
#+END_SRC
** C/C++
Company-C-Headers enables the completion of C/C++ header file names using company-mode:
#+begin_src emacs-lisp
(use-package company-c-headers
   :commands (c++-mode c-mode)
   :config
   (use-package company-irony
     :config
     (eval-after-load 'company
       '(add-to-list 'company-backends 'company-irony))
     (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
     )
   (require 'cc-mode)
   (require 'semantic)
   ;; C-mode and C++-mode specific bindings:
   (bind-key [(control tab)] 'company-complete c-mode-map)
   (bind-key [(control tab)] 'company-complete c++-mode-map)

   (add-to-list 'company-backends 'company-c-headers)
   ;(add-to-list 'company-c-headers-path-system "/usr/include/c++/4.8/")

   ;; *********** Available C style: ***************
   ;; “gnu”:    The default style for GNU projects
   ;; “k&r”:    What Kernighan and Ritchie, the authors of C used in their book
   ;; “bsd”:    What BSD developers use, aka “Allman style” after Eric Allman.
   ;; “whitesmith”: Popularized by the examples that came with Whitesmiths C, an early commercial C compiler.
   ;; “stroustrup”: What Stroustrup, the author of C++ used in his book
   ;; “ellemtel”:  Popular C++ coding standards as defined by “Programming in C++, Rules and Recommendations,”
   ;;             Erik Nyquist and Mats Henricson, Ellemtel
   ;; “linux”:  What the Linux developers use for kernel development
   ;; “python”:What Python developers use for extension modules
   ;; “java”:  The default style for java-mode (see below)
   ;; “user”:  When you want to define your own style
   ;; **********************************************
   (setq c-default-style "linux")  ;; set style to "linux"
   )
#+end_src

#+BEGIN_SRC emacs-lisp
(set-default 'semantic-case-fold t)

(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))

(defun my/cedet-hook ()
  (local-set-key "\C-c\C-j" 'semantic-ia-fast-jump)
  (local-set-key "\C-c\C-j" 'semantic-ia-fast-jump)
  (local-set-key "\C-c\C-s" 'semantic-ia-show-summary))

(add-hook 'c-mode-common-hook 'my/cedet-hook)
(add-hook 'c-mode-hook 'my/cedet-hook)
(add-hook 'c++-mode-hook 'my/cedet-hook)

(add-hook 'c-mode-common-hook 'hs-minor-mode)
#+end_src 

#+begin_src emacs-lisp
(use-package function-args
  :commands (c++-mode c-mode)
  :config
  (require cc-mode)
  (fa-config-default)
  (bind-key  [("C-c C-f C-h")] 'moo-complete c-mode-map)
  (bind-key [(control tab)] 'moo-complete c++-mode-map)
  (bind-key "C-c M-o s" 'fa-show c-mode-map)
  (bind-key "C-c M-o s" 'fa-show c++-mode-map)
  )
#+end_src

Don't ask if I really want to compile:
#+begin_src emacs-lisp
(global-set-key (kbd "<f5>") (lambda ()
                               (interactive)
                               (setq-local compilation-read-command nil)
                               (call-interactively 'compile)))

#+end_src

Enable Emacs Development Environment (EDE) only in C/C++:
#+begin_src emacs-lisp
(require 'ede)

(global-ede-mode)
#+END_SRC
 
* Organization and Version Control
** Magit
#+BEGIN_SRC  emacs-lisp
(use-package magit
  :commands magit-status
  :init
  (bind-key "C-c m s" 'magit-status))
#+END_SRC
*** backup specifics
#+BEGIN_SRC emacs-lisp
;; Backup function to target when called.
(defun my/backup-specifics (file target)
"Copy file to target and apply function"
    (if (not (file-exists-p file))
      (write-region "" nil file)) ; create file
    (if (file-exists-p target)
      (delete-file target))
    (copy-file file target))
#+END_SRC
*** On magit-push
#+BEGIN_SRC emacs-lisp
;; Advise magit-push to backup specifics.el to a backup file in home
(advice-add 'magit-push :around (lambda (push &rest args)
    (my/backup-specifics "specifics.el" "~/.emacsSpecificsBackup.el")
    (apply push args)))
#+END_SRC)
** Org Mode
Edit source code in org-mode:
#+begin_src emacs-lisp
  (bind-keys
   :map org-src-mode-map
   ("<C-return>" . org-edit-src-exit))
#+end_src
#+BEGIN_SRC emacs-lisp
(defun my-org-mode-hook ()
  (toggle-truncate-lines)
  (abbrev-mode 1)
  (toggle-word-wrap))

(add-hook 'org-mode-hook 'my-org-mode-hook)

(setq org-src-fontify-natively t)
#+END_SRC
*** column editing
#+BEGIN_SRC emacs-lisp
;(add-hook 'org-mode-hook 'my-org-mode-hook)
(global-set-key (kbd "C-c o k") 'org-mode-delete-column)
(global-set-key (kbd "C-c o i") 'org-mode-insert-column)
(global-set-key (kbd "C-c o j") 'org-mode-move-column-left)
(global-set-key (kbd "C-c o l") 'org-mode-move-column-right)

(global-set-key (kbd "C-c o RET") 'org-mode-todo-heading)
#+END_SRC
*** org-path-completion
#+BEGIN_SRC emacs-lisp
(setq org-goto-interface 'outline-path-completion
      org-goto-max-level 10)
#+END_SRC
*** org-capture
org-capture allows you to take a note anywhere, which it will write to the org-default-notes-file.
#+BEGIN_SRC emacs-lisp
;; this is set in ~/.emacs.d/custom/setup-specifics.el
(global-set-key (kbd "C-c c") 'org-capture)
#+END_SRC
*** org-back-to-top-level-heading
#+BEGIN_SRC elisp
;; move point to top-level heading
(defun org-back-to-top-level-heading ()
  "Go back to the current top level heading."
  (interactive)
  (or (re-search-backward "^\* " nil t)
      (goto-char (point-min))))

;; make todo's check recursively when determining the number of todo's under it
(setq org-hierarchical-todo-statistics nil)
#+END_SRC
*** org-summary-todo
This is for making sure that the top-level todo automatically is marked DONE if all sub-levels are DONE. 
TODO otherwise.
#+BEGIN_SRC elisp
(defun org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-log-states)   ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

(add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
#+END_SRC
*** jump-to-org-agenda
This is a snippet from John Wiegley. 
It shows org agenda after emacs has been idle for a certain amount of time.
#+BEGIN_SRC elisp
(defun jump-to-org-agenda ()
  (interactive)
  (let ((buf (get-buffer "*Org Agenda*"))
        wind)
    (if buf
        (if (setq wind (get-buffer-window buf))
            (select-window wind)
          (if (called-interactively-p)
              (progn
                (select-window (display-buffer buf t t))
                (org-fit-window-to-buffer)
                ;; (org-agenda-redo)
                )
            (with-selected-window (display-buffer buf)
              (org-fit-window-to-buffer)
              ;; (org-agenda-redo)
              )))
      (call-interactively 'org-agenda-list)))
  ;;(let ((buf (get-buffer "*Calendar*")))
  ;;  (unless (get-buffer-window buf)
  ;;    (org-agenda-goto-calendar)))
  )
(run-with-idle-timer 600 t 'jump-to-org-agenda)
#+END_SRC

* Emacs as an Web Interface
** Edit With Emacs (Google Chrome extension)
#+BEGIN_SRC emacs-lisp
;; Edit With Emacs (Google Chrome Extension)
(add-to-list 'load-path "~/.emacs.d/edit-with-emacs")
(use-package edit-server
  :config
  (edit-server-start))

#+END_SRC
** IRC
*** ERC
#+begin_src emacs-lisp
(use-package erc
  :defer t
  :init
  (defun my/erc-mode-hook ()
    (if (equal word-wrap nil)
     (toggle-word-wrap)))  
  :config
  (add-hook 'erc-mode-hook 'my/erc-mode-hook)
  (setq erc-hide-list '("PART" "QUIT" "JOIN"))
  (setq erc-autojoin-channels-alist '(("freenode.net"
                                       "#org-mode"
                                       "#emacs"))
        erc-server "irc.freenode.net"
        erc-nick "dwc1")
  (defun erc-cmd-DEOPME ()
    "Deop myself from current channel."
    (erc-cmd-DEOP (format "%s" (erc-current-nick))))
  )
#+end_src
** Functions
*** remove-headers
#+BEGIN_SRC emacs-lisp
(defun my/remove-headers ()
  (goto-char (point-min))
  (re-search-forward "^$")
  (goto-char (+ 1 (point)))
  (delete-region (point) (point-min)))
#+END_SRC

* Other Tools
** rgrep
#+BEGIN_SRC emacs-lisp 
(require 'dash)

(defun rgrep-fullscreen (regexp &optional files dir confirm)
  "Open grep in full screen, saving windows."
  (interactive
   (progn
     (grep-compute-defaults)
     (cond
      ((and grep-find-command (equal current-prefix-arg '(16)))
       (list (read-from-minibuffer "Run: " grep-find-command
                                   nil nil 'grep-find-history)))
      ((not grep-find-template)
       (error "grep.el: No `grep-find-template' available"))
      (t (let* ((regexp (grep-read-regexp))
                (files (grep-read-files regexp))
                (dir (ido-read-directory-name "Base directory: "
                                              nil default-directory t))
                (confirm (equal current-prefix-arg '(4))))
           (list regexp files dir confirm))))))
  (window-configuration-to-register ?$)
  (rgrep regexp files dir confirm)
  (switch-to-buffer "*grep*")
  (delete-other-windows)
  (beginning-of-buffer))
#+end_src

#+begin_src emacs-lisp
(defun rgrep-quit-window ()
  (interactive)
  (kill-buffer)
  (jump-to-register ?$))
#+end_src

#+begin_src emacs-lisp
(defun rgrep-goto-file-and-close-rgrep ()
  (interactive)
  (compile-goto-error)
  (kill-buffer "*grep*")
  (delete-other-windows)
  (message "Type C-x r j $ to return to pre-rgrep windows."))
#+end_src

#+begin_src emacs-lisp
(defvar git-grep-switches "--extended-regexp -I -n"
  "Switches to pass to `git grep'.")

(defun git-grep-fullscreen (regexp &optional files dir confirm)
  (interactive
   (let* ((regexp (grep-read-regexp))
          (files (grep-read-files regexp))
          (files (if (string= "* .*" files) "*" files))
          (dir (ido-read-directory-name "Base directory: "
                                        nil default-directory t))
          (confirm (equal current-prefix-arg '(4))))
     (list regexp files dir confirm)))
  (let ((command (format "cd %s && git --no-pager grep %s %s -e %S -- '%s' "
                         dir
                         git-grep-switches
                         (if (s-lowercase? regexp) " --ignore-case" "")
                         regexp
                         files))
        (grep-use-null-device nil))
    (when confirm
      (setq command (read-shell-command "Run git-grep: " command 'git-grep-history)))
    (window-configuration-to-register ?$)
    (grep command)
    (switch-to-buffer "*grep*")
    (delete-other-windows)
    (beginning-of-buffer)))
#+end_src

#+begin_src emacs-lisp
(eval-after-load "grep"
  '(progn
     ;; Don't recurse into some directories
     (add-to-list 'grep-find-ignored-directories "target")
     (add-to-list 'grep-find-ignored-directories "node_modules")
     (add-to-list 'grep-find-ignored-directories "vendor")

     ;; Add custom keybindings
     (define-key grep-mode-map "q" 'rgrep-quit-window)
     (define-key grep-mode-map (kbd "C-<return>") 'rgrep-goto-file-and-close-rgrep)
     (define-key grep-mode-map (kbd "C-x C-s") 'wgrep-save-all-buffers)

     ;; Use same keybinding as occur
     (setq wgrep-enable-key "e")))
#+end_src

#+begin_src emacs-lisp
(defvar grep-match-positions nil)
(make-variable-buffer-local 'grep-match-positions)

(defun grep-register-match-positions ()
  (save-excursion
    (forward-line 0)
    (let ((end (point)) beg)
      (goto-char compilation-filter-start)
      (forward-line 0)
      (setq beg (point))
      ;; Only operate on whole lines so we don't get caught with part of an
      ;; escape sequence in one chunk and the rest in another.
      (when (< (point) end)
        (setq end (copy-marker end))
        ;; Register all positions of matches
        (while (re-search-forward "\033\\[0?1;31m\\(.*?\\)\033\\[[0-9]*m" end 1)
          (add-to-list 'grep-match-positions (set-marker (make-marker) (match-beginning 1))))))))

(eval-after-load "grep"
  '(defadvice grep-mode (after grep-register-match-positions activate)
     (add-hook 'compilation-filter-hook 'grep-register-match-positions nil t)))
#+end_src

#+begin_src emacs-lisp
(defun add-cursors-to-all-matches ()
  (interactive)
  (--each grep-match-positions
    (unless (= 0 it-index)
      (mc/create-fake-cursor-at-point))
    (goto-char it))
  (mc/maybe-multiple-cursors-mode))

(eval-after-load "multiple-cursors"
  '(add-to-list 'mc--default-cmds-to-run-once 'mc/add-cursors-to-all-matches))

(eval-after-load "wgrep"
  '(define-key wgrep-mode-map (kbd "C-c C-æ") 'mc/add-cursors-to-all-matches))
#+END_SRC
